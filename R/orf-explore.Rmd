---
title: "ORF Exploration"
author: "Tyler H. Matta"

header-includes:
    - \usepackage{bm}
    - \usepackage{bbm}

output:
  html_document: default
  pdf_document: default    
---



Examinees are randomly assigned to groups, enabling the common group assumption. This assumption not only supposes that the ability distribution is the same at the start, but that the distribution of ability over time remains equal. 

Using a anchor form across each time point, we are able to understand how the ability distribution changes over time. That is, for the anchor group we assume the test characteristics remain unchanged, and it is ability that is changing over time. For this to hold, we must assume that changes in ability are not triggered by practice effects. This is a testable assumption with a proper design.  If the test is violated, one could conceivably correct for the practice effects.


A simple approach would be to linearly equate each form at a given time point to the anchor form using the scores from the same time point. 


single time point equating
multiple time points with diagonal matrices and vectors
multiple time points with covariances and vectors

However, one could also consider the set of scores over all time points simultaneously 




```{r}
options(stringsAsFactors = FALSE)
'%!in%' <- function(x,y)!('%in%'(x,y))

```

```{r loadData}
measure <- "orf"

fn <- paste0(measure, "-raw.csv")
ttl <- read.csv(file = paste(d_dir, fn, sep = "/"))
```


```{r}
grd <- 2

## Subset grade
ttl_g <- ttl[ttl$grade == grd, ]


## subset forms
table(ttl_g$probe_id, ttl_g$season)
```

```{r}
benchmarkId <- c(1, 2, 3)
anchorId <- 4
seasonId <- sort(unique(ttl_g$season))

ttl_g <- ttl_g[ttl_g$probe_id %in% c(benchmarkId, anchorId), ]

nrow(ttl_g)
length(unique(ttl_g$anon_id))

table(ttl_g$season, ttl_g$probe_id)
```


```{r}
ttl_g$season_probe <- paste(ttl_g$season, ttl_g$probe_id, sep = "-")

## Reshape to wide
ttl_g_w <- reshape(ttl_g[, c("anon_id", "season_probe", "total")],
                    timevar = "season_probe",
                    idvar = c("anon_id"),
                    direction = "wide", sep = "-")

anchorCols <- paste("total", seasonId, anchorId, sep = "-")
benchmarkCols <- paste("total", seasonId, benchmarkId, sep = "-")
ttl_g_w <- ttl_g_w[, c("anon_id", anchorCols , benchmarkCols)]

## Form pattern 
ttl_g_w$s1a <- ifelse(is.na(ttl_g_w[, anchorCols[1]]), "0", "A")
ttl_g_w$s2a <- ifelse(is.na(ttl_g_w[, anchorCols[2]]), "0", "A")
ttl_g_w$s3a <- ifelse(is.na(ttl_g_w[, anchorCols[3]]), "0", "A")
ttl_g_w$s1b <- ifelse(is.na(ttl_g_w[, benchmarkCols[1]]), "0", "B")
ttl_g_w$s2b <- ifelse(is.na(ttl_g_w[, benchmarkCols[2]]), "0", "B")
ttl_g_w$s3b <- ifelse(is.na(ttl_g_w[, benchmarkCols[3]]), "0", "B")

ttl_g_w$pattern <- paste0(ttl_g_w$s1a, ttl_g_w$s1b, "-", 
                         ttl_g_w$s2a, ttl_g_w$s2b, "-", 
                         ttl_g_w$s3a, ttl_g_w$s3b)

formPattern <- table(Pattern = ttl_g_w$pattern)
formPattern %>%
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

### WpM Distributions

```{r, echo=FALSE, fig.width=9, fig.height=6}
xMax <- 250
yMax <- 60
par(mfrow = c(2, 3))
hist(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 1], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 1, Form 4", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 2], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 2, Form 4", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 3], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 3, Form 4", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 1 & ttl_g$season == 1], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 1, Form 1", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 2 & ttl_g$season == 2], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 2, Form 2", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 3 & ttl_g$season == 3], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 3, Form 3", xlab = "Words per Minute")
```


### Univariate linear equating

Kolen and Brennan define a linear equating solution as:

$$
l_{a}(b) = \frac{\sigma_{a}}{\sigma_{b}} \mu_{b} + \left[ \mu_{a} - \frac{\sigma_{a}}{\sigma_{b}}\mu_{b} \right]
$$

where $(\mu_{a}, \, \sigma_{a})$ and $(\mu_{b}, \, \sigma_{b})$ are the empirical means and standard deviations for the anchor form and corresponding benchmark form, respectively.  


#### Empirical moments

We start by computing the empirical means and variances for the anchor form at each season. The means reside in `yEmpMeanVec` while the variances reside in `yEmpVarVec`, and `yEmpSdVec` contains the standard deviations.

```{r}
yEmpMeanVec <- c(mean(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 1]), 
                 mean(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 2]),
                 mean(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 3]))

yEmpVarVec <- c(var(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 1]), 
                var(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 2]),
                var(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 3]))

yEmpSdVec <- sqrt(yEmpVarVec)

yEmpMat <- rbind(yEmpMeanVec, yEmpVarVec, yEmpSdVec)
colnames(yEmpMat) <- c("1", "2", "3")

yEmpMat %>%
 kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

We do the same for each of the benchmark forms.

```{r, echo=TRUE}
xEmpMeanVec <- c(mean(ttl_g$total[ttl_g$probe_id == 1]), 
                 mean(ttl_g$total[ttl_g$probe_id == 2]),
                 mean(ttl_g$total[ttl_g$probe_id == 3]))

xEmpVarVec <- c(var(ttl_g$total[ttl_g$probe_id == 1]), 
                var(ttl_g$total[ttl_g$probe_id == 2]),
                var(ttl_g$total[ttl_g$probe_id == 3]))

xEmpSdVec <-  sqrt(xEmpVarVec)

xEmpMat <- rbind(xEmpMeanVec, xEmpVarVec, xEmpSdVec)
colnames(xEmpMat) <- c("1", "2", "3")

xEmpMat %>%
 kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```


#### Linear equating function

Next, we define the linear equating function to match that of defined in Kolen and Brennan. 

```{r, echo=TRUE}
linear_equate_x_to_y1 <- function(x, muY, sigmaY, muX, sigmaX)
{
  sigmaYBysigmaX <- sigmaY / sigmaX

  xEquateToY <- (sigmaYBysigmaX * x) + (muY - (sigmaYBysigmaX * muX)) 
  
  return(cbind.data.frame(rawX = x, equatedX = round(xEquateToY)))
}
```

`x` takes the observed score on the benchmark form
`muY` takes the mean for the anchor form
`sigmaY` takes the standard deviation for the anchor form
`muX` takes the mean for the benchmark form
`sigmaX` takes the standard deviation of the benchmark for 


We can also accomplish the same process using empirical variances instead of standard deviations. This solution proves more general when moving to a matrix solution. 

$$
l_{a}(b) = \left(\frac{\sigma^{2}_{a}}{\sigma^{2}_{b}} \right)^{1/2} \mu_{b} + \left[ \mu_{a} - \left(\frac{\sigma^{2}_{a}}{\sigma^{2}_{b}} \right)^{1/2}\mu_{b} \right]
$$


```{r}
linear_equate_x_to_y2 <- function(x, muY, sigmaY, muX, sigmaX)
{
  sigmaYBysigmaX <- sigmaY / sigmaX

  sqrt_sigmaYBysigmaX <- sqrt(sigmaYBysigmaX)

  xEquateToY <- (sqrt_sigmaYBysigmaX * x) + (muY - (sqrt_sigmaYBysigmaX * muX)) 
  
  return(cbind.data.frame(rawX = x, equatedX = round(xEquateToY)))
}
```



```{r, echo=TRUE}
xVec <- seq(from = 75, to = 175, by = 5)

linEqXToYSd <- linear_equate_x_to_y1(x      = xVec, 
                     muY    = yEmpMeanVec[1], 
                     sigmaY = yEmpSdVec[1], 
                     muX    = xEmpMeanVec[1], 
                     sigmaX = xEmpSdVec[1])

linEqXToYVar <- linear_equate_x_to_y2(x      = xVec, 
                     muY    = yEmpMeanVec[1], 
                     sigmaY = yEmpVarVec[1], 
                     muX    = xEmpMeanVec[1], 
                     sigmaX = xEmpVarVec[1])

cbind(raw = linEqXToYSd[, 1], "u-eq1" = linEqXToYSd[, 2], "u-eq2" = linEqXToYVar[, 2])
```



### Multivariate linear equating

Now, suppose we want to extend the univariate linking solution to equate a set of scores based on a set of means and variances. That is, rather than input a scalar value for the mean and variance, we utilize a vector valued mean and covariance matrix. 


$$
l_{a}(b) = \textrm{Chol}\left(\Sigma_{a}\Sigma_{b}^{-1}\right) \mu_{b} + \left[ \mu_{a} -\textrm{Chol}\left(\Sigma_{a}\Sigma_{b}^{-1}\right) \mu_{b} \right]
$$


```{r, echo=TRUE}
mv_linear_equate_x_to_y <- function(xVec, yMeanVec, yCovMat, xMeanVec, xCovMat)
{

  SigmaYInvSigmaX <- yCovMat %*% solve(xCovMat)
  cholSigmaYInvSigmaX <- chol(SigmaYInvSigmaX)
 
  xEquateToY <- cholSigmaYInvSigmaX %*% xVec + (yMeanVec - cholSigmaYInvSigmaX %*% xMeanVec)  

  return(cbind.data.frame(rawX = xVec, equatedX = round(xEquateToY)))
}
```

`xVec` takes a vector of total scores. 
`yMeanVec` takes the vector of means for the repeated anchor form
`yCovMat` takes a square matrix representing the covariance of the repeated anchor forms
`xMeanVec` takes the vector of means for the the multiple benchmark forms
`xCovMat` takes a square matrix representing the covariance of the multiple benchmark forms


We first demonstrate that equating each benchmarks to the repeated anchor form is equivalent to the multivariate equating when the off-diagonal of the covariance matrix is assumed to be zero.  We do this with a subset of responses in the data. 

```{r}
sub_ttl_g_w <- (ttl_g_w[ttl_g_w$pattern == "AB-AB-AB", ])
sub_ttl_g_w <- sub_ttl_g_w[, c("total-1-1", "total-2-2", "total-3-3")]
```

Equating with vector of empirical means and variances matrices (diag(Var)) 

```{r, echo=TRUE}
equate_out <- list()

for(jj in 1:nrow(sub_ttl_g_w))
{
  xVec_j <-  t(unname(as.matrix(sub_ttl_g_w[jj, ])))

  mvOut <- mv_linear_equate_x_to_y(xVec = xVec_j, 
                yMeanVec = yEmpMeanVec, 
                yCovMat = diag(yEmpVarVec), 
                xMeanVec = xEmpMeanVec, 
                xCovMat = diag(xEmpVarVec))
  
  
  uvOut <- linear_equate_x_to_y2(x = xVec_j, 
                        muY    = yEmpMeanVec, 
                        sigmaY = yEmpVarVec, 
                        muX    = xEmpMeanVec, 
                        sigmaX = xEmpVarVec)
  
  equate_out[[jj]] <- cbind("raw" = uvOut[, 1], "u-eq" = uvOut[, 2], "m-eq" = mvOut[, 2])
}
```

We see that based on the first 10 score sequences, the results from `mv_linear_equate_x_to_y` equal that of `linear_equate_x_to_y2`.


```{r}
 equate_out[1:10] 
```


### Multivariate linear equating with model-implied moments


We now use `mv_linear_equate_x_to_y` to equate the benchmark forms using model-implied moments based on mixed models that account for individual growth. 

### Model-based means and covariance matrix

We start by fitting a mixed effects model to the WPM associated with the repeated anchor form. 

$$
{\bf y}_{i} = {\bf X}_{i} \, \beta + {\bf Z}_{i} \, \zeta_{i} + \epsilon_{i}
$$
where
$$
\epsilon_{i} \sim \mathcal{N}(0, \psi^{2}) \textrm{ and } \zeta_{i} \sim \mathcal{N}({\bf 0}, \mathrm{T})
$$

We can then use the estimated fixed effects, $\beta$, estimated variance components, $\sigma^{2}$ and $\Sigma$, along with the design matrices ${\bf X}$ and ${\bf Z}$ to obtain the model implied mean and covariance matrices, 

\begin{align}
\mu_{a} &= {\bf X} \, \beta \\
\Sigma_{a} &= {\bf Z} \, \mathrm{T} \, {\bf Z}^{\prime} + \psi^{2} \bf{I}
\end{align}


```{r}
int <- rep(1, max(unique(ttl_g$season))) 
slp <- seq(0, max(ttl_g$season)-1)
Z <- X <- as.matrix(cbind(int, slp))
```

```{r}
aM1 <- lmer(total ~ 1 + season + (1 + season | anon_id), data = ttl_g[ttl_g$probe_id %in% anchorId, ])

aVarComp <- as.data.frame(VarCorr(aM1, order = "lower.tri"))$vcov

aCovMat <- matrix(NA, 2, 2)
aCovMat[1, 1] <- aVarComp[1]
aCovMat[2, 2] <- aVarComp[2]
aCovMat[1, 2] <- aCovMat[2, 1] <- aVarComp[3]
aResid <- aVarComp[4]

yModCovMat <- Z %*% aCovMat %*% t(Z) + diag(rep(aResid, nrow(Z)))
yModMeanVec <- X %*% fixef(aM1)

list(yModMeanVec, yModCovMat)

```
We then do the same thing using the series of benchmark forms. 


$$
{\bf z}_{i} = {\bf X}_{i} \, \beta + {\bf Z}_{i} \, \zeta_{i} + \epsilon_{i}
$$
where
$$
\epsilon_{i} \sim \mathcal{N}(0, \psi^{2}) \textrm{ and } \zeta_{i} \sim \mathcal{N}({\bf 0}, \mathrm{T})
$$

\begin{align}
\mu_{b} &= {\bf X} \, \beta \\
\Sigma_{b} &= {\bf Z} \, \mathrm{T} \, {\bf Z}^{\prime} + \psi^{2} \bf{I}
\end{align}

```{r}
bM1 <- lmer(total ~ 1 + season + (1 + season | anon_id), data = ttl_g[ttl_g$probe_id %in% benchmarkId, ])

bVarComp <- as.data.frame(VarCorr(bM1, order = "lower.tri"))$vcov

bCovMat <- matrix(NA, 2, 2)
bCovMat[1, 1] <- bVarComp[1]
bCovMat[2, 2] <- bVarComp[2]
bCovMat[1, 2] <- bCovMat[2, 1] <- bVarComp[3]
bResid <- bVarComp[4]

xModCovMat <- Z %*% bCovMat %*% t(Z) + diag(rep(bResid, nrow(Z)))
xModMeanVec <- X %*% fixef(bM1)

list(xMeanVec, xCovMat)

```

#### Multidimensional Equating


Equating with vector of model implied means and covariance matrices compared to empirical variances. 

```{r, echo=TRUE}
compare_equate_out2 <- list()

for(jj in 1:nrow(sub_ttl_g_w))
{
  xVec_j <-  t(unname(as.matrix(sub_ttl_g_w[jj, ])))

  mv1Out <- mv_linear_equate_x_to_y(xVec = xVec_j, 
                                    yMeanVec = yEmpMeanVec, 
                                    yCovMat = diag(yEmpVarVec), 
                                    xMeanVec = xEmpMeanVec, 
                                    xCovMat = diag(xEmpVarVec))
  
  
  mv2Out <- mv_linear_equate_x_to_y(x = xVec_j, 
                                    yMeanVec = yModMeanVec, 
                                    yCovMat  = yModCovMat, 
                                    xMeanVec  = xModMeanVec, 
                                    xCovMat  = xModCovMat)
  
  compare_equate_out2[[jj]] <- cbind(raw = mv1Out[, 1], "m-eq1" = mv1Out[, 2], "m-eq2" = mv2Out[, 2])
}
        
compare_equate_out2[1:10]


```