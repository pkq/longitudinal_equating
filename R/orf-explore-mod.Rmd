---
title: "ORF Exploration"
author: "Tyler H. Matta"

header-includes:
    - \usepackage{bm}
    - \usepackage{bbm}

output:
  html_document: default
  pdf_document: default    
---



Examinees are randomly assigned to groups, enabling the common group assumption. This assumption not only supposes that the ability distribution is the same at the start, but that the distribution of ability over time remains equal. 

Using a anchor form across each time point, we are able to understand how the ability distribution changes over time. That is, for the anchor group we assume the test characteristics remain unchanged, and it is ability that is changing over time. For this to hold, we must assume that changes in ability are not triggered by practice effects. This is a testable assumption with a proper design.  If the test is violated, one could conceivably correct for the practice effects.


A simple approach would be to linearly equate each form at a given time point to the anchor form using the scores from the same time point. 


single time point equating
multiple time points with diagonal matrices and vectors
multiple time points with covariances and vectors

However, one could also consider the set of scores over all time points simultaneously 




```{r}
options(stringsAsFactors = FALSE)
'%!in%' <- function(x,y)!('%in%'(x,y))
source("R/linear_equate_x_to_y1.R")
source("R/linear_equate_x_to_y2.R")
source("R/mv_linear_equate_x_to_y.R")
```

```{r loadData}
measure <- "orf"

library(rio)
library(knitr)
library(tidyverse)
fn <- paste0(measure, "-raw.csv")
#ttl <- read.csv(file = paste(d_dir, fn, sep = "/"))
ttl <- import("~/Code/CTL/aip/validation/2017/output/anon_scores.xlsx", which = 3)
```

```{r}
grd <- 2

## Subset grade
ttl_g <- ttl[ttl$grade == grd, ]

## subset forms
table(ttl_g$probe_id, ttl_g$season)
```

```{r}
benchmarkId <- c(1, 2, 3)
anchorId <- 4
seasonId <- sort(unique(ttl_g$season))

ttl_g <- ttl_g[ttl_g$probe_id %in% c(benchmarkId, anchorId), ]

nrow(ttl_g)
length(unique(ttl_g$anon_id))

table(ttl_g$season, ttl_g$probe_id)
```


```{r}
ttl_g$season_probe <- paste(ttl_g$season, ttl_g$probe_id, sep = "-")

## Reshape to wide
ttl_g_w <- reshape(ttl_g[, c("anon_id", "season_probe", "total")],
                    timevar = "season_probe",
                    idvar = c("anon_id"),
                    direction = "wide", sep = "-")

anchorCols <- paste("total", seasonId, anchorId, sep = "-")
benchmarkCols <- paste("total", seasonId, benchmarkId, sep = "-")
ttl_g_w <- ttl_g_w[, c("anon_id", anchorCols , benchmarkCols)]

## Form pattern 
ttl_g_w$s1a <- ifelse(is.na(ttl_g_w[, anchorCols[1]]), "0", "A")
ttl_g_w$s2a <- ifelse(is.na(ttl_g_w[, anchorCols[2]]), "0", "A")
ttl_g_w$s3a <- ifelse(is.na(ttl_g_w[, anchorCols[3]]), "0", "A")
ttl_g_w$s1b <- ifelse(is.na(ttl_g_w[, benchmarkCols[1]]), "0", "B")
ttl_g_w$s2b <- ifelse(is.na(ttl_g_w[, benchmarkCols[2]]), "0", "B")
ttl_g_w$s3b <- ifelse(is.na(ttl_g_w[, benchmarkCols[3]]), "0", "B")

ttl_g_w$pattern <- paste0(ttl_g_w$s1a, ttl_g_w$s1b, "-", 
                         ttl_g_w$s2a, ttl_g_w$s2b, "-", 
                         ttl_g_w$s3a, ttl_g_w$s3b)

formPattern <- table(Pattern = ttl_g_w$pattern)
formPattern %>%
  kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

### WpM Distributions

```{r, echo=FALSE, fig.width=9, fig.height=6}
xMax <- 250
yMax <- 60
par(mfrow = c(2, 3))
hist(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 1], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 1, Form 4", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 2], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 2, Form 4", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 3], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 3, Form 4", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 1 & ttl_g$season == 1], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 1, Form 1", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 2 & ttl_g$season == 2], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 2, Form 2", xlab = "Words per Minute")
hist(ttl_g$total[ttl_g$probe_id == 3 & ttl_g$season == 3], ylim = c(0, yMax), xlim = c(0, xMax),
     main = "Season 3, Form 3", xlab = "Words per Minute")
```


### Univariate linear equating

Kolen and Brennan define a linear equating solution as:

$$
l_{a}(b) = \frac{\sigma_{a}}{\sigma_{b}} \mu_{b} + \left[ \mu_{a} - \frac{\sigma_{a}}{\sigma_{b}}\mu_{b} \right]
$$

where $(\mu_{a}, \, \sigma_{a})$ and $(\mu_{b}, \, \sigma_{b})$ are the empirical means and standard deviations for the anchor form and corresponding benchmark form, respectively.  


#### Empirical moments

We start by computing the empirical means and variances for the anchor form at each season. The means reside in `yEmpMeanVec` while the variances reside in `yEmpVarVec`, and `yEmpSdVec` contains the standard deviations.

```{r}
yEmpMeanVec <- c(mean(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 1]), 
                 mean(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 2]),
                 mean(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 3]))

yEmpVarVec <- c(var(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 1]), 
                var(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 2]),
                var(ttl_g$total[ttl_g$probe_id == 4 & ttl_g$season == 3]))

yEmpSdVec <- sqrt(yEmpVarVec)

yEmpMat <- rbind(yEmpMeanVec, yEmpVarVec, yEmpSdVec)
colnames(yEmpMat) <- c("1", "2", "3")

yEmpMat %>%
 kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

We do the same for each of the benchmark forms.

```{r, echo=TRUE}
xEmpMeanVec <- c(mean(ttl_g$total[ttl_g$probe_id == 1]), 
                 mean(ttl_g$total[ttl_g$probe_id == 2]),
                 mean(ttl_g$total[ttl_g$probe_id == 3]))

xEmpVarVec <- c(var(ttl_g$total[ttl_g$probe_id == 1]), 
                var(ttl_g$total[ttl_g$probe_id == 2]),
                var(ttl_g$total[ttl_g$probe_id == 3]))

xEmpSdVec <-  sqrt(xEmpVarVec)

xEmpMat <- rbind(xEmpMeanVec, xEmpVarVec, xEmpSdVec)
colnames(xEmpMat) <- c("1", "2", "3")

xEmpMat %>%
 kable() %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```


#### Linear equating function


We can equate the tests using empirical variances instead of standard deviations. This solution proves more general when moving to a matrix solution. 

$$
l_{a}(b) = \left(\frac{\sigma^{2}_{a}}{\sigma^{2}_{b}} \right)^{1/2} \mu_{b} + \left[ \mu_{a} - \left(\frac{\sigma^{2}_{a}}{\sigma^{2}_{b}} \right)^{1/2}\mu_{b} \right]
$$


The following demonstrates that the equation above, namely taking the square root of the divisor of the variances is identical to divding the standard deviations.

```{r, echo=TRUE}
xVec <- seq(from = 75, to = 175, by = 5)

linEqXToYSd <- linear_equate_x_to_y1(
                     x      = xVec, 
                     muY    = yEmpMeanVec[1], 
                     sigmaY = yEmpSdVec[1], 
                     muX    = xEmpMeanVec[1], 
                     sigmaX = xEmpSdVec[1])

linEqXToYVar <- linear_equate_x_to_y2(
                     x      = xVec, 
                     muY    = yEmpMeanVec[1], 
                     sigmaY = yEmpVarVec[1], 
                     muX    = xEmpMeanVec[1], 
                     sigmaX = xEmpVarVec[1])

cbind(raw = linEqXToYSd[, 1], "u-eq1" = linEqXToYSd[, 2], "u-eq2" = linEqXToYVar[, 2])
```


### Multivariate linear equating

Now, suppose we want to extend the univariate linking solution to equate a set of scores based on a set of means and variances. That is, rather than input a scalar value for the mean and variance, we utilize a vector valued mean and covariance matrix. 


$$
l_{a}(b) = \textrm{Chol}\left(\Sigma_{a}\Sigma_{b}^{-1}\right) \mu_{b} + \left[ \mu_{a} -\textrm{Chol}\left(\Sigma_{a}\Sigma_{b}^{-1}\right) \mu_{b} \right]
$$



`xVec` takes a vector of total scores. 
`yMeanVec` takes the vector of means for the repeated anchor form
`yCovMat` takes a square matrix representing the covariance of the repeated anchor forms
`xMeanVec` takes the vector of means for the the multiple benchmark forms
`xCovMat` takes a square matrix representing the covariance of the multiple benchmark forms


We first demonstrate that equating each benchmarks to the repeated anchor form is equivalent to the multivariate equating when the off-diagonal of the covariance matrix is assumed to be zero.  We do this with a subset of responses in the data. 

```{r}
sub_ttl_g_w <- (ttl_g_w[ttl_g_w$pattern == "AB-AB-AB", ])
sub_ttl_g_w <- sub_ttl_g_w[, c("total-1-1", "total-2-2", "total-3-3")]
```

Equating with vector of empirical means and variances matrices (diag(Var)) 

```{r, echo=TRUE}
equate_out <- list()

for(jj in 1:nrow(sub_ttl_g_w))
{
  xVec_j <-  t(unname(as.matrix(sub_ttl_g_w[jj, ])))

  mvOut <- mv_linear_equate_x_to_y(xVec = xVec_j, 
                yMeanVec = yEmpMeanVec, 
                yCovMat = diag(yEmpVarVec), 
                xMeanVec = xEmpMeanVec, 
                xCovMat = diag(xEmpVarVec))
  
  
  uvOut <- linear_equate_x_to_y2(x = xVec_j, 
                        muY    = yEmpMeanVec, 
                        sigmaY = yEmpVarVec, 
                        muX    = xEmpMeanVec, 
                        sigmaX = xEmpVarVec)
  
  equate_out[[jj]] <- cbind("raw" = uvOut[, 1], "u-eq" = uvOut[, 2], "m-eq" = mvOut[, 2])
}
```

We see that based on the first 10 score sequences, the results from `mv_linear_equate_x_to_y` equal that of `linear_equate_x_to_y2`.


```{r}
 equate_out[1:10] 
```

### Multivariate linear equating with model-implied moments


We now use `mv_linear_equate_x_to_y` to equate the benchmark forms using model-implied moments based on mixed models that account for individual growth. 

### Model-based means and covariance matrix

We start by fitting a mixed effects model to the WPM associated with the repeated anchor form. 

$$
{\bf y}_{i} = {\bf X}_{i} \, \beta + {\bf Z}_{i} \, \zeta_{i} + \epsilon_{i}
$$
where
$$
\epsilon_{i} \sim \mathcal{N}(0, \psi^{2}) \textrm{ and } \zeta_{i} \sim \mathcal{N}({\bf 0}, \mathrm{T})
$$

We can then use the estimated fixed effects, $\beta$, estimated variance components, $\sigma^{2}$ and $\Sigma$, along with the design matrices ${\bf X}$ and ${\bf Z}$ to obtain the model implied mean and covariance matrices, 

\begin{align}
\mu_{a} &= {\bf X} \, \beta \\
\Sigma_{a} &= {\bf Z} \, \mathrm{T} \, {\bf Z}^{\prime} + \psi^{2} \bf{I}
\end{align}


```{r}
int <- rep(1, max(unique(ttl_g$season))) 
slp <- seq(0, max(ttl_g$season)-1)
Z <- X <- as.matrix(cbind(int, slp))
```

```{r}
aM1 <- lmer(total ~ 1 + season + (1 + season | anon_id), data = ttl_g[ttl_g$probe_id %in% anchorId, ])

aVarComp <- as.data.frame(VarCorr(aM1, order = "lower.tri"))$vcov

aCovMat <- matrix(NA, 2, 2)
aCovMat[1, 1] <- aVarComp[1]
aCovMat[2, 2] <- aVarComp[2]
aCovMat[1, 2] <- aCovMat[2, 1] <- aVarComp[3]
aResid <- aVarComp[4]

yModCovMat <- Z %*% aCovMat %*% t(Z) + diag(rep(aResid, nrow(Z)))
yModMeanVec <- X %*% fixef(aM1)

list(yModMeanVec, yModCovMat)

```
We then do the same thing using the series of benchmark forms. 


$$
{\bf w}_{i} = {\bf X}_{i} \, \beta + {\bf Z}_{i} \, \zeta_{i} + \epsilon_{i}
$$
where
$$
\epsilon_{i} \sim \mathcal{N}(0, \psi^{2}) \textrm{ and } \zeta_{i} \sim \mathcal{N}({\bf 0}, \mathrm{T})
$$

\begin{align}
\mu_{b} &= {\bf X} \, \beta \\
\Sigma_{b} &= {\bf Z} \, \mathrm{T} \, {\bf Z}^{\prime} + \psi^{2} \bf{I}
\end{align}

```{r}
bM1 <- lmer(total ~ 1 + season + (1 + season | anon_id), data = ttl_g[ttl_g$probe_id %in% benchmarkId, ])

bVarComp <- as.data.frame(VarCorr(bM1, order = "lower.tri"))$vcov

bCovMat <- matrix(NA, 2, 2)
bCovMat[1, 1] <- bVarComp[1]
bCovMat[2, 2] <- bVarComp[2]
bCovMat[1, 2] <- bCovMat[2, 1] <- bVarComp[3]
bResid <- bVarComp[4]

xModCovMat <- Z %*% bCovMat %*% t(Z) + diag(rep(bResid, nrow(Z)))
xModMeanVec <- X %*% fixef(bM1)

list(xMeanVec, xCovMat)

```

#### Multidimensional Equating


Equating with vector of model implied means and covariance matrices compared to empirical variances. 

`m-eq1` uses of the sample means and variances
`m-eq2` uses of the model-implied means and variances (contraining the covariances to zero)
`m-eq3` uses of the model-implied means and covariance matrix (same variances as `m-eq2` with covariances unconstrained)

```{r, echo=TRUE}
compare_equate_out2 <- list()

for (jj in 1:nrow(sub_ttl_g_w))
{
  xVec_j <-  t(unname(as.matrix(sub_ttl_g_w[jj, ])))

  mv1Out <- mv_linear_equate_x_to_y(xVec     = xVec_j, 
                                    yMeanVec = yEmpMeanVec, 
                                    yCovMat  = diag(yEmpVarVec), 
                                    xMeanVec = xEmpMeanVec, 
                                    xCovMat  = diag(xEmpVarVec))
  
  mv2Out <- mv_linear_equate_x_to_y(x        = xVec_j, 
                                    yMeanVec = yModMeanVec, 
                                    yCovMat  = diag(diag(yModCovMat)), 
                                    xMeanVec = xModMeanVec, 
                                    xCovMat  = diag(diag(xModCovMat))) 

  mv3Out <- mv_linear_equate_x_to_y(x        = xVec_j, 
                                    yMeanVec = yModMeanVec, 
                                    yCovMat  = yModCovMat, 
                                    xMeanVec = xModMeanVec, 
                                    xCovMat  = xModCovMat)
  
  compare_equate_out2[[jj]] <- cbind("raw"   = mv1Out[, 1], 
                                     "m-eq1" = mv1Out[, 2], 
                                     "m-eq2" = mv2Out[, 2], 
                                     "m-eq3" = mv3Out[, 2])
}
        
compare_equate_out2[1:10]


```
